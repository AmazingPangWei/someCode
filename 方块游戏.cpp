////总觉得这道题过得有点侥幸，思路也很简单，现在跟大家分享一下吧
////做这题就是模拟一下方块下落的过程，也没用到什么算法
////利用结构体来存长条的区间，每次输入，我们遍历一次已经下落的方块，以此来确定本次方块落下的位置
////然后是本题的N有些大，二维数组不好存，所以我选择用的vector来存区间。
////
////具体代码如下：
//
//
//
//#include <iostream>
//#include <vector>
//using namespace std;
//
//struct area //区间
//{
//	int l, r;
//};
//
//
//vector<area> a[100000];
//int ans[100000]; //每一个方块所在的位置
//int main()
//{
//	
//	int n;
//	cin >> n;
//
//	int temp = 0;//最大的层数
//
////初始第一次方块在第一层
//	area t;
//	cin >> t.l >> t.r;
//	a[1].push_back(t);
//	temp++; 
//	ans[1] = 1;
//
////之后的方块根据之前的方块来确定位置
//	for (int i = 2; i <= n; i++)//输入剩下的区间
//	{
//		cin >> t.l >> t.r;
//		int j, k;
//		for (j = temp; j >= 1; j--)//开始遍历之前已经落下的行
//		{
//			int L = a[j].size();
//			for(k=0;k<L;k++)//遍历该行的方块的区间
//				//如果这个方块下面有方块
//				if ((t.l >= a[j][k].l && t.l <= a[j][k].r) || (t.r >= a[j][k].l && t.r <= a[j][k].r) || (t.l<=a[j][k].l && t.r>=a[j][k].r))
//				{
//					if (j == temp)//如果下面的方块已经是最大的一层
//					{
//						temp++;//最大的一层+1，这个方块成为新的最大层
//					}
//					ans[i] = j+1;
//					a[j+1].push_back(t);
//					break;
//				}
//			if (k != L)//判断是否遍历到了下面的方块，遍历到了，则跳出循环
//				break;
//		}
//		//遍历完了j，而下面没有方块，说明已经到底了
//		if (j == 0)//到底了
//		{
//			a[1].push_back(t);
//			ans[i] = 1;
//		}
//
//	}
//
//	for (int i = 1; i <= n; i++)
//		cout << ans[i] << endl;
//
//	
//
////	system("pause");
//	return 0;
//}